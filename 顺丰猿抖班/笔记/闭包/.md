# 闭包
- 理解
能够读取其他函数内部变量的函数；
定义在一个函数内部的函数(有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。)
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数极限访问定义时的词法作用域。

- 可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。
1. 保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突
2. 在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）
3. 匿名自执行函数可以减少内存消耗

- 特性
1. 函数嵌套函数
2. 函数内部可以引用函数外部的参数和变量
3. 参数和变量不会被垃圾回收机制回收

- 缺点
1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除（在使用完变量后手动为它赋值为null）
2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
3. 由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响


i是声明在全局作用中的，定时器中的匿名函数也是执行在全局作用域中，
for (var i = 0; i <= 10; i++) {
    setTimeout(() => {
        console.log(i) // 10个11
    }, 1000)
}


让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值。
for (var i = 0; i <= 10; i++) {
    (function () {
        var j = i
        setTimeout(() => {
            console.log(j) // 0...10
        }, 1000)
    })()
}

将每次迭代的i作为实参传递给自执行函数，自执行函数中用变量去接收
for (var i = 0; i <= 10; i++) {
    (function (j) {
        setTimeout(() => {
            console.log(j) // 0...10
        }, 1000)
    })(i)
}

实现每隔1秒打印
for (var i = 0; i <= 10; i++) {
    (function (j) {
        setTimeout(() => {
            console.log(j) // 0...10
        }, i* 1000)
    })(i)
}


# 闭包的应用
- 闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部(1.html)